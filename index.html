<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="编码计算、架构技术、服务器技术、云计算技术、挖掘机技术...." />



  <meta name="keywords" content="编程,写作,体验" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="编码计算、架构技术、服务器技术、云计算技术、挖掘机技术....">
<meta property="og:type" content="website">
<meta property="og:title" content="大后端">
<meta property="og:url" content="http://www.dahouduan.com/index.html">
<meta property="og:site_name" content="大后端">
<meta property="og:description" content="编码计算、架构技术、服务器技术、云计算技术、挖掘机技术....">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大后端">
<meta name="twitter:description" content="编码计算、架构技术、服务器技术、云计算技术、挖掘机技术....">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> 大后端 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?74a54215aac26eec91b8c5fe54a20033";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">大后端</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/" itemprop="url">
                bigdata-filebeat-elasticsearch-kibana-elk
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-10-17T11:53:06+08:00" content="2016-10-17">
            2016-10-17
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Filebeat_+_Elasitcsearch_+_Kibana_搭建日志收集系统">Filebeat + Elasitcsearch + Kibana 搭建日志收集系统</h1><p><img src="media/14764103978219/14764370554119.jpg" alt="">￼</p>
<img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14764370554119.jpg" alt="[kibana后台]" title="[kibana后台]">
<h2 id="1-为什么需要日志收集">1.为什么需要日志收集</h2><p>当我们的网站规模大到一定程度时我们的服务分散在不同的主机上，当网站发生异常时我们通常通过这些服务的日志来排查系统故障，由于主机众多日志分散在不同的主机上，导致我们分析日志效率太低，日志收集系统可以实现将所有不同主机的上的日志汇聚到一个系统中，方便我们查看，分析。</p>
<h2 id="2-开源软件选型">2.开源软件选型</h2><p>市面上有各种日志收集系统，通过多个开瑞软件整合来完成日志收集分析，大概包括si个部分：<br><code>收集 -&gt; 分析 -&gt; 存储 -&gt; 后台</code><br>做收集的有Apache的 Flume， Facebook的 Scribe，Elasic 的 Firebeat，Logstash<br>做分析，Logstash可以，别的暂时没有研究，还用不到<br>做存储的有 Elasticsearch，Hdfs（Hadoop , Storm） 等<br>做后台的有 kibana，grafana</p>
<p>用Hdfs的这种基本是做日志的大数据分析的，比较重，不太适合我们，Eliastic 有一套完整的日志方案就是<br>通常说的 Elk(Elasticsearch + Logstash + kibana)，   Logstash比较大，一般用他来做日志的分析格式化（二次处理），日志收集用 Firebeat， Flume也不错，不过需要装java环境，Friebeat 用go写的，对环境每依赖可以直接运行，而且很轻量大概 3M 多，这对部署实施时很有利。</p>
<p>Eliasticsearch 搜索的高效就不用说了，存时序数据也经常用它，对这个本身也有过一定了解</p>
<p>Kibana 用来做日志查看分析，跟Elasticsearch 配合起来使用，可以通过从es里搜索出来的数据做可视化展示，Dashboard数据监控面板</p>
<p>所以最后选择通过 Filebeat + Elasitcsearch + Kibana 来实现我们的日志收集系统（Logstash 可选）</p>
<p>目前Kibana稳定版在 4.4 ，但是要依赖 Elasticsearch 2 以上，<br>以前用过 Elasticsearch 1.7 的，所以选了 Elasticsearch 1.7 + Kibana 4.1</p>
<h2 id="3-安装部署">3.安装部署</h2><p>centos 6.x 环境下</p>
<h3 id="3-1_在日志所在服务器上安装Filebeat">3.1 在日志所在服务器上安装Filebeat</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --<span class="keyword">import</span> <span class="string">https:</span><span class="comment">//packages.elastic.co/GPG-KEY-elasticsearch</span></span><br></pre></td></tr></table></figure>
<p>将以下内容</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[beats]</span></span><br><span class="line"><span class="setting">name=<span class="value">Elastic Beats Repository</span></span></span><br><span class="line"><span class="setting">baseurl=<span class="value">https://packages.elastic.co/beats/yum/el/<span class="variable">$basearch</span></span></span></span><br><span class="line"><span class="setting">enabled=<span class="value"><span class="number">1</span></span></span></span><br><span class="line"><span class="setting">gpgkey=<span class="value">https://packages.elastic.co/GPG-KEY-elasticsearch</span></span></span><br><span class="line"><span class="setting">gpgcheck=<span class="value"><span class="number">1</span></span></span></span><br></pre></td></tr></table></figure>
<p>保存为 <code>/etc/yum.repos.d/beat.repo</code> 文件</p>
<p>开始安装</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="operator"><span class="keyword">install</span> filebeat</span><br><span class="line">chkconfig <span class="comment">--add filebeat</span></span></span><br></pre></td></tr></table></figure>
<p>启动命令</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/filebeat <span class="built_in">start</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2_在日志服务器安装_Elasticsearch">3.2 在日志服务器安装 Elasticsearch</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/download &amp;&amp; cd ~/download</span><br><span class="line">wget -c https:<span class="comment">//download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.7.2.zip</span></span><br><span class="line">unzip elasticsearch-<span class="number">1.7</span><span class="number">.2</span>.zip </span><br><span class="line">mv elasticsearch-<span class="number">1.7</span><span class="number">.2</span> /usr/local/elasticsearch</span><br></pre></td></tr></table></figure>
<p>启动命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/elasticsearch/bin</span><br><span class="line">./elasticsearch <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3_在日志服务器安装_Kibana">3.3 在日志服务器安装 Kibana</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:<span class="comment">//packages.elastic.co/GPG-KEY-elasticsearch</span></span><br><span class="line">cat &gt; /etc/yum<span class="class">.repos</span><span class="class">.d</span>/kibana<span class="class">.repo</span>  </span><br><span class="line"></span><br><span class="line">[kibana-<span class="number">4.1</span>]</span><br><span class="line">name=Kibana repository <span class="keyword">for</span> <span class="number">4.1</span><span class="class">.x</span> packages</span><br><span class="line">baseurl=http:<span class="comment">//packages.elastic.co/kibana/4.1/centos</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http:<span class="comment">//packages.elastic.co/GPG-KEY-elasticsearch</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install kibana</span><br><span class="line">chkconfig --add kibana</span><br></pre></td></tr></table></figure>
<p>启动命令</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/kibana <span class="built_in">start</span></span><br></pre></td></tr></table></figure>
<h2 id="4-使用方法">4.使用方法</h2><p>假如我们有一台 web 服务器， 上面跑了nginx + php-fpm，我们要收集php-fpm的 错误日志和慢日志</p>
<h3 id="4-1配置_filebeat">4.1配置 filebeat</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">filebeat</span>:</span><br><span class="line">  <span class="attribute">prospectors</span>:</span><br><span class="line">    -</span><br><span class="line">      <span class="attribute">document_type</span>: <span class="string">"php-fpm"</span></span><br><span class="line">      <span class="attribute">paths</span>:</span><br><span class="line">        - /var/log/php/php-fpm.log</span><br><span class="line">    -</span><br><span class="line">      <span class="attribute">document_type</span>: <span class="string">"php-fpm.slow"</span></span><br><span class="line">      <span class="attribute">paths</span>:</span><br><span class="line">        - /var/log/php/slow.log</span><br><span class="line">      <span class="attribute">multiline</span>:</span><br><span class="line">          <span class="attribute">pattern</span>: <span class="string">'^[[:space:]]'</span></span><br><span class="line">          <span class="attribute">negate</span>: true</span><br><span class="line">          <span class="attribute">match</span>: after</span><br><span class="line"><span class="attribute">output</span>:</span><br><span class="line">  <span class="attribute">elasticsearch</span>:</span><br><span class="line">    <span class="attribute">hosts</span>: [<span class="string">"192.168.1.88:9200"</span>]</span><br><span class="line"><span class="attribute">shipper</span>:</span><br><span class="line">  <span class="attribute">tags</span>: [<span class="string">"web"</span>]</span><br></pre></td></tr></table></figure>
<p>上面的配置表示从 <code>/var/log/server/php/php-fpm.log</code>, <code>/var/log/server/php/cloud.slow.log</code> 这两个位置收集日志，<br>其中由于 slow 日志存在多行的做为一条记录的情况，filebeat 通过三个配置来将多行转为一行, <code>pattern</code>, <code>negate</code>, <code>match</code>, 上面的配置表示，如果不是以空白开头的行将被拼接到上一行的后面，<br>pattern 遵循golang的正则语法</p>
<p><code>output</code> 指令中指定将日志输出到 <code>elasticsearch</code>,并添加了服务所在ip 和端口，可以添加多台，还能支持负均衡</p>
<p><code>shipper</code> 中可以指定一些tag，方便后面在 kibana 中筛选数据</p>
<p>好了，重启filebeat就可以了， <code>/etc/init.d/filebeat restart</code></p>
<h3 id="4-2_配置Elasticsearch">4.2 配置Elasticsearch</h3><p>确保 Elasticsearch 已经启动</p>
<h3 id="4-3_配置kibana">4.3 配置kibana</h3><p>安装 filebeat 的示例仪表盘等</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> -p ~/download &amp;&amp; <span class="keyword">cd</span> ~/download</span><br><span class="line">curl -<span class="keyword">L</span> -O http:<span class="comment">//download.elastic.co/beats/dashboards/beats-dashboards-1.3.1.zip</span></span><br><span class="line">unzip beats-dashboards-1.3.1.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">cd</span> beats-dashboards-1.3.1/</span><br><span class="line">./load.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，脚本假设在127.0.0.1:9200上运行Elasticsearch。 使用-url选项指定其他位置。 例如：<code>./load.sh -url http://192.168.1.88:9200</code> 。</p>
<p>kibana中需要配置 elasticsearch 的地址和端口，现在两个服务都是在同一台上，配置默认是 <code>localhost:9200</code>,所以也不用改</p>
<h3 id="4-4_打开kibana">4.4 打开kibana</h3><p>kibana 启动后默认 端口是 5601 ， 从浏览器打开 <code>http://192.168.1.88:5601</code><br>kibana 会加载一个 5m的js ，所以要先耐心等待</p>
<p>打开后界面是这样的</p>
<img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14764368818734.jpg" alt="[kibana后台2]" title="[kibana后台2]">
<p>改成 filebeat-*<br><img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14764369227720.jpg" alt="[kibana后台2]" title="[kibana后台2]"></p>
<p>点 create ，然后点 Discover, 进来后如果日志中有数据，我们应该可以看到类似下面的界面</p>
<img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14764370554119.jpg" alt="[kibana后台2]" title="[kibana后台2]">
<p>区域说明</p>
<img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14764374467022.jpg" alt="[kibana后台2]" title="[kibana后台2]">
<p>点 <code>type</code> 可以看到我们在filebeat 中指定的日志名称  </p>
<img src="/2016/10/17/bigdata-filebeat-elasticsearch-kibana-elk/14766732444502.jpg" alt="[kibana后台2]" title="[kibana后台2]">
<p>还有更多功能自己发掘把。</p>
<h2 id="4-5_参考资料">4.5 参考资料</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//www.elastic.<span class="keyword">co</span>/guide/<span class="keyword">en</span>/beats/filebeat/current/filebeat-getting-started.html</span><br><span class="line">http<span class="variable">s:</span>//www.elastic.<span class="keyword">co</span>/guide/<span class="keyword">en</span>/kibana/current/getting-started.html</span><br><span class="line">http<span class="variable">s:</span>//www.elastic.<span class="keyword">co</span>/guide/<span class="keyword">en</span>/elasticsearch/guide/current/getting-started.html</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/24/Tutorial-zookeeper-kafka-storm-cluster/" itemprop="url">
                zookeeper kafka storm 集群安装与使用
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-02-24T16:47:34+08:00" content="2016-02-24">
            2016-02-24
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/24/Tutorial-zookeeper-kafka-storm-cluster/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/24/Tutorial-zookeeper-kafka-storm-cluster/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="环境">环境</h2><p>一共三台测试机</p>
<ul>
<li>操作系统: centos7 ; hostname: c1 ; ip: 192.168.33.21</li>
<li>操作系统: centos7 ; hostname: c2 ; ip: 192.168.33.22</li>
<li>操作系统: centos7 ; hostname: c3 ; ip: 192.168.33.23</li>
</ul>
<h2 id="zookeeper">zookeeper</h2><h3 id="安装">安装</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">mkdir</span> -p download &amp;&amp; <span class="keyword">cd</span> download</span><br><span class="line">wget -c http:<span class="comment">//www.eu.apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz</span></span><br><span class="line"></span><br><span class="line">tar xvzf zookeeper-3.4.6.tar.gz</span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/server</span><br><span class="line">cp -r zookeeper-3.4.6 /usr/<span class="keyword">local</span>/server/zookeeper</span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/server/zookeeper/<span class="keyword">conf</span></span><br><span class="line">touch zoo.cfg</span><br></pre></td></tr></table></figure>
<p>打开 <code>zoo.cfg</code></p>
<p>添加 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">dataDir=/data/zookeeper</span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line">initLimit=<span class="number">5</span></span><br><span class="line">syncLimit=<span class="number">2</span></span><br><span class="line">server<span class="number">.1</span>=c1:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.2</span>=c2:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line">server<span class="number">.3</span>=c3:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure>
<p>打开 <code>/etc/hosts</code><br>添加<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.33</span><span class="number">.20</span> c1</span><br><span class="line"><span class="number">192.168</span><span class="number">.33</span><span class="number">.21</span> c2</span><br><span class="line"><span class="number">192.168</span><span class="number">.33</span><span class="number">.22</span> c3</span><br></pre></td></tr></table></figure></p>
<p>创建数据目录<br><code>mkdir -p /data/zookeeper</code></p>
<p>创建myid文件， id 与 zoo.cfg 中的序号对应<br><code>echo 1 &gt; /data/zookeeper/my.id</code></p>
<h3 id="常用命令">常用命令</h3><p>启动</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkServer.sh start 
</code></pre><p>重启</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkServer.sh restart
</code></pre><p>关闭</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkServer.sh stop
</code></pre><p>在其中一台用客户端连接</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkCli.sh -server <span class="string">c1:</span><span class="number">2181</span>
</code></pre><p>查看状态</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkServer.sh status
</code></pre><h3 id="测试">测试</h3><p>在 c1 上连接 c1 上的 zookeeper </p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkCli.sh -server <span class="string">c1:</span><span class="number">2181</span>
</code></pre><p>添加一个根节点目录</p>
<pre><code><span class="operator"><span class="keyword">create</span> /<span class="keyword">project</span>  xxxx</span>
</code></pre><p>在 c2 上连接 c2 上的 zookeeper</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>zookeeper<span class="regexp">/bin/</span>zkCli.sh -server <span class="string">c2:</span><span class="number">2181</span>
</code></pre><p>执行</p>
<pre><code><span class="keyword">get</span> /project
</code></pre><p>看是否能得到数据,如果有 zookeeper 集群就完成了</p>
<h3 id="备注">备注</h3><ul>
<li>注意要关闭防火墙</li>
</ul>
<h2 id="kafka">kafka</h2><p>Producer在发布消息到某个Partition时，先通过Zookeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。<br>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。但考虑到这种场景非常少见，可以认为这种方式在性能和数据持久化上做了一个比较好的平衡。在将来的版本中，Kafka会考虑提供更高的持久性。<br>Consumer读消息也是从Leader读取，只有被commit过的消息（offset低于HW的消息）才会暴露给Consumer。</p>
<p>Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）</p>
<h3 id="安装-1">安装</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~/download</span><br><span class="line">wget -c <span class="string">http:</span><span class="comment">//ftp.jaist.ac.jp/pub/apache/kafka/0.8.2.2/kafka_2.10-0.8.2.2.tgz</span></span><br><span class="line">cp -r kafka_2<span class="number">.10</span>-<span class="number">0.8</span><span class="number">.2</span><span class="number">.2</span> <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka</span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka/conf</span><br><span class="line">mkdir -p <span class="regexp">/data/</span>storm</span><br></pre></td></tr></table></figure>
<p>在 c1 上<br>打开 <code>server.properties</code>，<br>修改以下项<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">borker=<span class="number">1</span> </span><br><span class="line">host.name=c1</span><br><span class="line">zookeeper.connect=c1:<span class="number">2181</span>,c2:<span class="number">2181</span>,c3:<span class="number">2181</span></span><br></pre></td></tr></table></figure></p>
<p>c2 上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">borker=<span class="number">2</span> </span><br><span class="line">host.name=c2</span><br><span class="line">zookeeper.connect=c1:<span class="number">2181</span>,c2:<span class="number">2181</span>,c3:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<p>c3 上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">borker=<span class="number">3</span> </span><br><span class="line">host.name=c3</span><br><span class="line">zookeeper.connect=c1:<span class="number">2181</span>,c2:<span class="number">2181</span>,c3:<span class="number">2181</span></span><br></pre></td></tr></table></figure>
<p>保存</p>
<h3 id="常用命令-1">常用命令</h3><p>启动</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-server-start.sh -daemon <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/config/</span>server.properties   
</code></pre><p>关闭</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-server-stop.sh
</code></pre><p>创建 topic</p>
<pre><code><span class="comment">/usr/local/server/kafka/bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">log</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">c1:2181/kafka</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span>
</code></pre><p>列出 topic</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-topics.sh --list --zookeeper <span class="string">c1:</span><span class="number">2181</span>/kafka
</code></pre><p>列出 topic 详细信息</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-topics.sh --describe --zookeeper <span class="string">c1:</span><span class="number">2181</span>/kafka    
</code></pre><p>生产数据</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-console-producer.sh --broker-list <span class="string">c1:</span><span class="number">9092</span> --topic topic1
</code></pre><p>消费数据</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/server/</span>kafka<span class="regexp">/bin/</span>kafka-console-consumer.sh --zookeeper <span class="string">c2:</span><span class="number">2181</span> --topic topic1
</code></pre><h3 id="测试-1">测试</h3><pre><code><span class="comment">/usr/local/server/kafka/bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">c1:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span>
<span class="comment">/usr/local/server/kafka/bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test2</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">c1:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span>
<span class="comment">/usr/local/server/kafka/bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">c1:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">3</span>

<span class="comment">/usr/local/server/kafka/bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test4</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">c1:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">3</span>
</code></pre><h3 id="删除topic">删除topic</h3><p>登录 zookeeper，删除 <code>/kafka/brokers/topics/topic1</code> <code>/kafka/config/topics/test1</code><br>删除 kafka 日志目录 <code>/tmp/kafka-logs</code> 下对应的 topic 分区文件</p>
<h2 id="storm">storm</h2><h3 id="安装-2">安装</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~/download</span><br><span class="line">wget -c <span class="string">http:</span><span class="comment">//ftp.jaist.ac.jp/pub/apache/storm/apache-storm-0.9.6/apache-storm-0.9.6.tar.gz</span></span><br><span class="line">tar xvzf apache-storm-<span class="number">0.9</span><span class="number">.6</span>.tar.gz</span><br><span class="line"></span><br><span class="line">cp -r apache-storm-<span class="number">0.9</span><span class="number">.6</span> <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>storm</span><br><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>storm/conf</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="regexp">/data/</span>storm</span><br></pre></td></tr></table></figure>
<p>我们把 c1 做为 nimbus，c2 c3 做为 supervisord，所以配置如下</p>
<p>打开 <code>storm.yaml</code> 修改 <code>storm.zookeeper.servers</code> 为<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storm.zookeeper.servers:</span><br><span class="line">    -<span class="ruby"> <span class="string">"c1"</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="string">"c2"</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="string">"c3"</span></span></span><br></pre></td></tr></table></figure></p>
<p>修改 <code>nimbus.host</code> 为</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nimbus<span class="class">.host</span>: <span class="string">"c1"</span></span><br></pre></td></tr></table></figure>
<p>添加  <code>storm.local.dir=/data/storm</code><br>保存</p>
<h3 id="常用命令-2">常用命令</h3><p>启动 nimbus （c1 上） </p>
<pre><code>nohup <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>storm<span class="regexp">/bin/</span>storm nimbus &gt;<span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;
</code></pre><p>启动 Supervisor (c2,c3 上)</p>
<pre><code>nohup <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>storm<span class="regexp">/bin/</span>storm supervisor &gt;<span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;
</code></pre><p>启动 storm ui (c1 上)</p>
<pre><code>nohup <span class="regexp">/usr/</span>local<span class="regexp">/server/</span>storm<span class="regexp">/bin/</span>storm ui &gt;<span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;
</code></pre><p>访问 storm ui 可以通过 <a href="http://c1:8080/" target="_blank" rel="external">http://c1:8080/</a></p>
<p>关闭 storm</p>
<pre><code>kill -<span class="number">9</span> `ps aux | <span class="keyword">grep</span> storm | <span class="keyword">grep</span> -v <span class="keyword">grep</span> | awk <span class="string">'{print $2}'</span>` &gt; <span class="regexp">/dev/</span><span class="keyword">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;
</code></pre><p>提交 topology</p>
<pre><code>./storm jar  ~/Workdir/workspace/storm-demo/target/demo-<span class="number">1.0</span>-SNAPSHOT<span class="class">.jar</span> storm_demo<span class="class">.demo</span><span class="class">.App</span> pro -c nimbus.host=c1
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/27/git-add/" itemprop="url">
                git add 的本质
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-27T19:03:44+08:00" content="2015-11-27">
            2015-11-27
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/27/git-add/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/27/git-add/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>当我刚开始学 git 的时候，我一直都不明白为什么要有 <code>git add</code> 这个命令，感觉 git 提交好麻烦<br>我需要</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add xxx.md</span><br><span class="line">git <span class="operator"><span class="keyword">commit</span> -<span class="keyword">m</span> <span class="string">"add xxx"</span></span><br><span class="line">git push origin <span class="keyword">master</span></span></span><br></pre></td></tr></table></figure>
<p>才能把一个文件提交到远端， 我怀念起了我之前一直用的 svn ,想想一个 <code>svn commit</code>就都搞定了，git 为什么这么麻烦？</p>
<p>用的多用的久了，我才发现了 git 的好处，说为什么 git 比 svn 好用，我的理解大概因为 git 把修改， 提交，协作，合并，都解耦到了一个个过程中,使得发生错误的情况很少，项目版本的可维护性很高。<br>当然，很多地方我还理解的不是很深，我现在只说下为什么要有 <code>git add</code> 这个命令。</p>
<p><strong>git add 的本质是维护你下一次要提交的文件清单</strong>。</p>
<p>举个例子：<br>比如你在开发一个功能，文件已经改了好多了，但是都没有提交，也没有<code>git add</code>，这时候老板让你紧急添加一个功能，为了实现这个功能, 你修改个了a,b,c三个文件，你可以把这三个文件 <code>git add</code> 进来，这样这三个文件就进了下次要提交的文件清单，等快要提交的时候，你发现有个c文件是不需要修改的，你可以 <code>git reset c</code>, 将 c 从清单从去掉，这时候 <code>git commit</code> 就会只提交 a，b 文件，你也不会担心提交了那些以前修改过的文件。</p>
<p><code>git add</code> 关键是将修改添加到清单，而不是文件添加到清单<br>举个例子：</p>
<p>假如一个已经在版本控制下的文件 <code>a.txt</code>，内容是</p>
<pre><code><span class="title">Hello</span> world
</code></pre><p>然后你又添加了一行</p>
<pre><code><span class="title">Hello</span> world
Hello china
</code></pre><p>你可以然后执行 <code>git add a.txt</code> , 那么下一次 <code>git commit</code>这个改变就会被提交, 但是假如还没来得及 <code>git commit</code>，你又添加了一行</p>
<pre><code><span class="title">Hello</span> world
Hello china
Hello beijing
</code></pre><p>如果你没有再次 <code>git add a.txt</code>, 这次修改是不会被提交的</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/11/10/storm-tutorial/" itemprop="url">
                Storm 入门教程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-11-10T20:06:40+08:00" content="2015-11-10">
            2015-11-10
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/11/10/storm-tutorial/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/10/storm-tutorial/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在这个教程中，你将学会如何创建 Storm 的topology并将他们部署到 Storm 集群上， 主要的语言是 Java，但是少数几个例子用 Python 编写来说明 Storm 的多语言支持能力。</p>
<h2 id="写在前面">写在前面</h2><p>这个教程使用的例子来自 <a href="https://github.com/apache/storm/blob/master/examples/storm-starter" target="_blank" rel="external">strom-starter</a> 项目 ,建议你克隆这个项目到本地，然后跟着这些例子来，你可以先读下  <a href="http://storm.apache.org/documentation/Setting-up-development-environment.html" target="_blank" rel="external">配置开发环境</a> 和 <a href="http://storm.apache.org/documentation/Creating-a-new-Storm-project.html" target="_blank" rel="external">创建一个storm项目</a> 来部署好你本地的开发环境。</p>
<h2 id="术语和名词">术语和名词</h2><p>MapReduce jobs<br>topologies topology 由用户编写的Storm集群中的业务处理逻辑<br>deamon 守护进程<br>worker process 工作进程<br>stream 流 指Storm中的数据流<br>tuple 元组 指stream中的最小单元数据<br>primitive 基件  指storm topology 的组成部分，比如 bolt 和 spout<br>task 任务</p>
<h2 id="Storm_集群里的各种组件">Storm 集群里的各种组件</h2><p>从表面上看一个 Storm 集群 与 一个 Hadoop 集群相似，然而在 Hadoop 上运行 “MapReduce jobs”, 在 Storm 上运行 “topologies”, 但是 “jobs” 和 “topologies” 是非常不同的– 一个关键的不同是 MapReduce job 最终会结束，而一个 topology 是永远在等待消息并处理（直到你杀掉它）。</p>
<p>一个 Storm 集群中有两种节点(node)：主节点和工作节点，主节点运行一个叫 “Nimbus” 的守护进程（daemon）跟 Hadoop 的  “任务跟踪器”（Jobtracker）类似。Nimbus 负责向集群中分发代码， 向各机器分配任务，以及监测故障。</p>
<p><strong> 这里的节点是指Storm集群中不同角色的服务器节点 </strong></p>
<p>每一个工作节点运行一个名叫 “Supervisor” 的守护进程。Supervisor 监听 Nimbus 指派到这个这台机器的任务，根据 Numbus 的指派信息来停启工作进程(worker process) ，每一个 worker process 执行一个topology的子集，一个运行中的topology由跨越多个主机的多个 worker process 组成。</p>
<img src="/2015/11/10/storm-tutorial/storm-cluster.png" alt="[Storm集群示意图]" title="[Storm集群示意图]">
<p>在 Nimbus 和 Supervisors 之间的所有协调调度通过一个 <a href="http://zookeeper.apache.org/" target="_blank" rel="external">Zookeeper</a> 集群来完成。另外，Nimbus 守护进程和 Supervisor 守护进程都是快速失败 （fail-fast）和无状态的；所有的状态保存在 Zookeeper 或者本地磁盘中。这意味着你可以 <code>kill -9</code> Nimbus 或者 Supervisors 他们会自动恢复，就像什么都没发生过一样。这种设计让 Storm 集群变的不可思议的稳定。</p>
<h2 id="Topologies">Topologies</h2><p>在Strom上做实时计算， 你需要创建 “Topology”，一个 topology 是一个计算过程的描述，一个 topology 中的每一个节点包含处理逻辑，节点之间的连接表明了数据在节点之间是如何传递的。</p>
<p><strong> 这里的节点是指 topology 中计算过程的每一个步骤 </strong></p>
<p>运行一个 是很简单的。首先，你将你所有的代码和依赖都打包到一个单独的jar包中，然后运行像下面这样的命令：</p>
<pre><code>storm jar all-my-<span class="tag">code</span><span class="class">.jar</span> backtype<span class="class">.storm</span><span class="class">.MyTopology</span> arg1 arg2
</code></pre><p>这样会传递<code>arg1</code>和 <code>arg2</code>参数给<code>backtype.storm.MyTopology</code>类，这个类的 <code>main</code> 方法定义topology 并将它提交到 Nimbus。<code>Strom jar</code> 部分负责连接 Nimbus 并上传jar包.</p>
<p>由于 topology 的定义本来就是 Thrift 结构，并且 Nimbus 是一个 Thrift 服务， 所以你可以使用任何编程语言来创建和提交 topology。上面的方法是使用基于 JVM 的编程语言来完成的最简单的方法，参考<a href="http://storm.apache.org/documentation/Running-topologies-on-a-production-cluster.html" target="_blank" rel="external">Running topologies on a production cluster</a> 来获取更多的关于开启和停止 topology 的方法。</p>
<h2 id="Streams">Streams</h2><p>Strom 的核心抽象概念是 “流” （stream），一个 stream 相当于一个无限的元组(tuple) 序列，Storm 提供了以可靠且分布式的方法来将一个 stream 转换成一个新 stream 的基件 (primitive) ，例如你可能想将一个微博的 stream 来转成一个热门话题的 stream。</p>
<p>Storm提供基本的用来做流转换的的基件是  “spout” 和 “bolts” ，spout 和 bolt 提供了接口，你可以实现这些接口来处理的你自己的应用程序相关的逻辑。</p>
<p>spout 是流的来源， 例如 spout 可以从一个 <a href="http://github.com/nathanmarz/storm-kestrel" target="_blank" rel="external">Kestrel</a> 队列来读 tuple 并且发射(emit)他们形成一个流，或者 spout 可以连接到 Twitter api，来发射一个推文的流。</p>
<p>一个 bolt 消费任意数量的流， 做一些处理，然后可能会发射出新的流，复杂的流转换，例如从一个推文的流计算出一个热门话题的流，需要多个步骤，多个 bolt 。bolt可以通过运行函数（functions）来做任何事，例如过滤元组，做流聚合，做流连接，跟数据库交互等等。</p>
<p>所有的 spout 和 bolt 被打包到了一个 “topology” 中 ，topology 是你提交给 Storm 集群来执行的计算过程的最高抽象，一个 topology 类似一个流转换的图表，它现显示了哪些 bolt 是绑定(subscribe)哪些 stream 上的 。当一个 spout 或者 bolt 发射出一个 tuple 到 stream 中，它会发送 tuple 到所有绑定了这个 stream 的 bolt 中。</p>
<img src="/2015/11/10/storm-tutorial/topology.png" alt="[spout和bolt的关系图]" title="[spout和bolt的关系图]">
<p>topology 中节点之间的连接表明了 tuple 是如何在他们之间传递的。例如如果在 spout A 和 bolt B 之间有一个连接，从 spout A 到 bolt C 之间有一个连接，从 boltB 到 boltC 有一个连接，tuple 会发到 bolt B 和 bolt C 中， 所有 bolt B 的输出 tuple 也会流到 bolt C 中</p>
<p><strong> 这里的节点是指 topology 中的 spout 或者 bolt </strong><br>topology中的每一个节点都是并行执行的。在你的topology中，你可以指定每个节点的并行数量n，然后 Storm会启动 n 个线程在集群中运行</p>
<p>一个 topology 是永远运行的，直到你杀掉它，Storm 会自动重新分配失败的任务。另外，Storm 保证没有数据丢失， 即使主机挂掉消息丢失。</p>
<h2 id="数据模型">数据模型</h2><p>Storm 使用 tuple 做数据模型，一个 tuple 是被命名过的值列表，一个 tuple 中的字段可以是任何类型的对象。它是开箱即用的，Storm 支持所有的简单数据类型，如字符串，字节数组作为 tuple 的字段值。如果要使用另一种类型的对象，你只需要为这个类型实现一个 <a href="http://storm.apache.org/documentation/Serialization.html" target="_blank" rel="external">serializer</a></p>
<p>topology 中的每一个节点都应该为它要发射的元组声明输出字段， 例如， 下面这个bolt声明了它发射字段为 “double” 和 “triple” 字段的元组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleAndTripleBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputCollectorBase _collector;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollectorBase collector)</span> </span>&#123;</span><br><span class="line">        _collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = input.getInteger(<span class="number">0</span>);        </span><br><span class="line">        _collector.emit(input, <span class="keyword">new</span> Values(val*<span class="number">2</span>, val*<span class="number">3</span>));</span><br><span class="line">        _collector.ack(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"double"</span>, <span class="string">"triple"</span>));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>declareOutputFields</code> 方法声明了输出字段为<code>[&quot;double&quot;, &quot;triple&quot;]</code>,<br>这个 bolt 类的其他部分将在下面的章节中讲解。</p>
<h2 id="一个简单的topology">一个简单的topology</h2><p>让我们来看一个简单的 topology 来探索更多的概念，看代码是如何构造起来的。我们从 storm-starter 项目里看看 <code>ExclamationTopology</code> 是如何定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();        </span><br><span class="line">builder.setSpout(<span class="string">"words"</span>, <span class="keyword">new</span> TestWordSpout(), <span class="number">10</span>);        </span><br><span class="line">builder.setBolt(<span class="string">"exclaim1"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">3</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"words"</span>);</span><br><span class="line">builder.setBolt(<span class="string">"exclaim2"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">2</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"exclaim1"</span>);</span><br></pre></td></tr></table></figure>
<p>这个 topology 包含一个 spout 和两个 bolt，spout 发送单词，每一个 bolt 附加 “!!!” 到它的输入数据中。这些节点排练成一条线：spout 先发射 tuple 到第一个 bolt，然后第一个 bolt 发送到第二个 bolt。如果 spout 发送 [“bob”] 和 [“john”] 元组，然后第二个bolt会发送 [“bob!!!!!!”] 和 [“john!!!!!!”] 元组</p>
<p>代码中使用 <code>setSpout</code> 和 <code>setBolt</code> 方法来定义节点.这些方法需要传入一个用户指定的id，一个包含处理逻辑的对象，以及你希望这个节点运行的并行数量。在这个例子中，spout 被指定了id “words”, bolt 被指定了id “exclaim1” 和 “exclaim2”</p>
<p>传入的 Spout 对象实现了 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/IRichSpout.html" target="_blank" rel="external">IRichSpout</a> 接口并包含业务逻辑</p>
<p>传入的 Bolt 对象实现了 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/IRichBolt.html" target="_blank" rel="external">IRichBolt</a>   接口并包含业务逻辑</p>
<p>最后一个参数，你想要这个节点的并行数量是几，这个参数是可选的，它表明有多少线程应该在集群中运行该 组件 ，如果你忽略了它，Storm 会给这个节点只分配一个线程</p>
<p><strong> 这里的组件是指被实例化后的节点，即 spout 或者 bolt </strong></p>
<p><code>setBolt</code> 返回一个 <a href="http://storm.apache.org/javadoc/apidocs/backtype/storm/topology/InputDeclarer.html" target="_blank" rel="external">InputDeclarer</a> 对象用来给 bolt 定义输入。这 “exclaim1”组件 声明了它要想读入所有 “words” 组件的发射的打乱分组过的所有 tuple.</p>
<p>“exclaim2” 组件声明了它要读入所有 “exclaim1” 发射的打乱分组过的 tuple，”打乱分组”（shuffile group）意味着 tuple 必须从输入中随机分发到 bolt 的任务中。有许多在组件之间将数据分组的方法，打乱只是其中一种。接下来的一些小节会解释到它。</p>
<p>如果你希望 “exclaim2” 组件，既读取 “words” 又读取 “exclaim1” 发射的 tuple ， 你可以像如下这样实现 “excliam2” ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.setBolt(<span class="string">"exclaim2"</span>, <span class="keyword">new</span> ExclamationBolt(), <span class="number">5</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"words"</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"exclaim1"</span>);</span><br></pre></td></tr></table></figure>
<p>正如你所见，可以给 bolt 链式的指定多个数据源。</p>
<p>让我们深入到这个 topology 中 spouts 和 bolts 的具体实现上。Spouts 负责发射新的消息到 topology中， 在这个 topology 中 <code>TestWordSpouts</code>方法 从 [“nathan”, “mike”, “jackson”, “golda”, “bertels”]  中每 100毫秒 发射一个随机的字符， TestWordSpout 中 <code>nextTuple()</code>方法 的实现是这样的: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Utils.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">final</span> String[] words = <span class="keyword">new</span> String[] &#123;<span class="string">"nathan"</span>, <span class="string">"mike"</span>, <span class="string">"jackson"</span>, <span class="string">"golda"</span>, <span class="string">"bertels"</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">final</span> String word = words[rand.nextInt(words.length)];</span><br><span class="line">    _collector.emit(<span class="keyword">new</span> Values(word));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，这种实现非常的简单。</p>
<p><code>ExclamationBolt</code> 附加 “!!!” 到输入中， 让我们看看 <code>ExclamationBolt</code> 的完整实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="class"><span class="keyword">class</span> <span class="title">ExclamationBolt</span> <span class="title">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line">    OutputCollector _collector;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> prepare(<span class="built_in">Map</span> conf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        _collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> execute(Tuple tuple) &#123;</span><br><span class="line">        _collector.emit(tuple, <span class="keyword">new</span> Values(tuple.getString(<span class="number">0</span>) + <span class="string">"!!!"</span>));</span><br><span class="line">        _collector.ack(tuple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> cleanup() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="built_in">Map</span> getComponentConfiguration() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepare</code> 方法给 bolt 提供了一个 <code>OutputCollector</code> 对象用来从这个 bolt 中发射 tuple 。 在这个 bolt 中的任何位置都可以发射 tuples  – <code>prepare</code>, <code>execute</code>, <code>cleanup</code> 方法， 甚至在异步的其他线程中。<code>prepare</code> 方法仅仅保持一个 <code>OutputCollector</code> 对象实例以便在后面 <code>execute</code> 方法中调用。</p>
<p><code>execute</code> 方法从输入中接收一个 tuple。<code>ExclamationBolt</code> 从元组中取到第一个字段，然后在后面附加 “!!!” 。 如果你实现的 bolt 订阅了多个输入源， 你可以使用 <code>Tuple#getSourceComponent</code> 方法查到当前的 tuple 是来自哪个组件. </p>
<p><code>execute</code> 方法里还可以做一些其他操作，即将输入的 tuple 作为 emit 的第一个参数传入，这样这个 tuple 会被确认。这是 Storm 可靠api一部分它能保证，不会丢失数据，这些在本教程后面的章节中还会阐述。</p>
<p><code>cleanup</code> 方法会在 Bolt 停止时被调用，用来关闭清理所有打开的资源。不能保证这个方法一定会在集群中被调用，如果正在运行的机器发生了爆炸（作者在搞笑），这样就没办法调用这个方法了。<code>cleanup</code>方法其实是专门为你在<a href="http://storm.apache.org/documentation/Local-mode.html" target="_blank" rel="external">本地模式</a>(将Storm集群在一个进程中模拟出来)下运行 topology ，你希望运行和杀掉 topology 而不必担心资源泄露。</p>
<p><code>declareOutputFields</code> 方法声明 <code>ExclamationBolt</code> 发射包含一个 word 字段的 tuple </p>
<p><code>getComponentConfiguration</code> 方法允许你配置影响这个 bolt 如何运行的各种参数，有一个更高级的话题专门讨论关于配置的更多内容 <a href="http://storm.apache.org/documentation/Configuration.html" target="_blank" rel="external">Configuration</a>.</p>
<p>像<code>cleanup</code> 和 <code>getComponentConfiguration</code> 方法通常并不是必须的， 你可以通过继承一个提供了默认实现的基类来更简洁的定义 bolt。 通过继承 <code>BaseRichBolt</code>类 ，<code>ExclamationBolt</code>可以被实现的更简洁，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclamationBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    OutputCollector _collector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map conf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        _collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple)</span> </span>&#123;</span><br><span class="line">        _collector.emit(tuple, <span class="keyword">new</span> Values(tuple.getString(<span class="number">0</span>) + <span class="string">"!!!"</span>));</span><br><span class="line">        _collector.ack(tuple);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在本地模式下运行_ExclamationTopology">在本地模式下运行 ExclamationTopology</h2><p>我们来看下如何在本地模式下运行 <code>ExclamationTopology</code> </p>
<p>Storm 有两种运行模式：本地模式和分布式模式。在本地模式中，Storm 完全在一个进程中运行，用线程来模拟各个工作节点。本地模式对与开发和测试topology是非常有用的，当你运行 storm-starter 中的 topology时，它会运行在本地模式下，你可以看到每一个组件发射的消息，你可以阅读更多关于<a href="http://storm.apache.org/documentation/Local-mode.html" target="_blank" rel="external">本地模式</a>的内容</p>
<p>在分布式模式下，Storm 运行在一组机器上，当你提交一个 topology 到 master上，就会同时提交所有必要的代码来运行这个 topology，master会负责分发你的代码，并分配工作进程来运行你的 topology，如果工作进程挂掉了，master会在某处重新分配他们。你可以阅读更多关于<a href="http://storm.apache.org/documentation/Running-topologies-on-a-production-cluster.html" target="_blank" rel="external">在一个集群上来运行topology</a>的内容,</p>
<p>下面是在本地模式运行 <code>ExclamationTopology</code> 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line">conf.setNumWorkers(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">cluster.submitTopology(<span class="string">"test"</span>, conf, builder.createTopology());</span><br><span class="line">Utils.sleep(<span class="number">10000</span>);</span><br><span class="line">cluster.killTopology(<span class="string">"test"</span>);</span><br><span class="line">cluster.shutdown();</span><br></pre></td></tr></table></figure>
<p>首先，这段代码通过创建 <code>LocalCluster</code> 对象定义了一个进程内的集群。提交 topology 到虚拟集群和提交到分布式集群是一样的，通过调用 <code>submitTopology</code> 来向 <code>LocalCluster</code> 中提交 topology，它接受三个参数，topology的名字，topology的配置，topology本身。</p>
<p>名字是用来识别这个 topology，以便日后杀掉它。。topology会一直运行直到你杀掉它。</p>
<p>配置是用来调优运行 topology 的各个方面，下面是两个常见的配置：</p>
<ol>
<li>TOPOLOGY_WORKERS (用 <code>setNumWorkers</code>来设置) 指定你将在集群分配几个进程来运行这个这个topology，topology中的每一个组件会被当做多个线程来运行。一个组件被分配线程的数量通过 <code>setBolt</code> 和 <code>setSpout</code> 方法来配置，这些线程存在于工作进程中。每个工作进程包含一些组件中的一些线程，例如，你分配了 300 个线程给所有的组件，在配置中设置了50个工作进程，那么每个工作进程会运行6个线程，每一个线程可能属于不同的组件。通过调整每个元件的并行度和运行这些线程的工作进程的数量来对 storm 的并行性能调优。</li>
<li>TOPOLOGY_DEBUG （通过 setDebug 设置）,当被设为 true 时，storm 将记录元件发射的每个消息，在本地模式测试topology时这是很有用的，但是在线上模式运行时，你更愿意将它关闭</li>
</ol>
<h2 id="流分组_Stream_groupings">流分组 Stream groupings</h2><p>流分组让 topology 知道在组件之间如何发送 tuple，记住 spouts 和 bolts 是被当成很多 tasks 并行运行在整个集群中的，如果你想看看 topology 是如何在 task 层级运行的，就像下图这样</p>
<p><strong> 这里的task 就是setBolt和 setSpout 中产生的工作线程，如果设置了数量，就是线程组或者任务组即 set of tasks </strong></p>
<p>当一个运行 Bolt A 的 task 发射了一个 tuple 到 Bolt B，那么它应该发射到哪个 task（当然是运行Bolt B 的task） 呢？ </p>
<p>流分组 （Stream grouping）答了这个问题，它告诉 Storm 如何在 set of task（任务组）之间发送 tuple，在我们深入不同种类的流分组以前，让我们看看 <a href="http://github.com/apache/storm/blob/master/examples/storm-starter" target="_blank" rel="external">storm-start</a> 里的另一个 topology ，<a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/storm/starter/WordCountTopology.java" target="_blank" rel="external">WordCountTopology</a>从一个 spout 中读取句子并且从 <code>WordCountBolt</code> 中获取某个单词出现的次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line"></span><br><span class="line">builder.setSpout(<span class="string">"sentences"</span>, <span class="keyword">new</span> RandomSentenceSpout(), <span class="number">5</span>);        </span><br><span class="line">builder.setBolt(<span class="string">"split"</span>, <span class="keyword">new</span> SplitSentence(), <span class="number">8</span>)</span><br><span class="line">        .shuffleGrouping(<span class="string">"sentences"</span>);</span><br><span class="line">builder.setBolt(<span class="string">"count"</span>, <span class="keyword">new</span> WordCount(), <span class="number">12</span>)</span><br><span class="line">        .fieldsGrouping(<span class="string">"split"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br></pre></td></tr></table></figure>
<p><code>SplitSentence</code> 把它接收到的每一个句子中的每一个单词当做 tuple 发送出去，<code>WordCount</code> 在内存中维护了一个单词和数量的映射关系，每次 <code>WordCount</code> 接收到一个单词，它就更新单词的数量，然后发送新的单词数量。</p>
<p>当然还有一些不同种类的流分组。</p>
<p>基本的分组类型叫做 “乱序分组(shuffle grouping)” ，它将使 tuple 被随机发个一个 task，<code>WordCountTopology</code>中 使用了乱序分组来从 <code>RandomSentenceSpout</code> 向 <code>SplitSentence</code> 发送 tuple， 这样所有的处理任务就能够被平均的分配到所有运行 <code>SplitSentence</code> Bolt的 task 上。</p>
<p>一个更有趣的分组类型是 <code>字段分组(fields grouping)</code> ，<code>SplitSentence</code> 和 <code>WordCount</code> 之间使用了一个字段分组，<code>WordCount</code>能够运作的一个极为重要的要求是相同的单词必须被发到同一个 task中，否则会有一个以上的 task 会接收到相同的单词，然后他们会发射错误的计数。字段分组使我们可以用字段将一个流分组，这使得相同字段的内容总是被分到同一个task中。由于 <code>WordCount</code> 在 <code>word</code> 字段上使用字段分组订阅了 <code>SplitSentence</code>‘s 的输出流，这样相同的单词总是会进入到相同的task.</p>
<p>字段分组是流连接和流聚合以及许多其他用力的基本实现，究其原理，字段分组是通过 mod hashing（哈希的一种） 来实现的</p>
<p>还有一些其他类型的分组，你可以在<a href="http://storm.apache.org/documentation/Concepts.html" target="_blank" rel="external">概念</a>里查看更多。</p>
<h2 id="使用其他编程语言编写_Bolt">使用其他编程语言编写 Bolt</h2><p>Bolt 可以使用其他编程语言编写，使用其他语言编写的 Bolt 会被当做子进程来执行，Storm 通过 stdin/stdout 用json格式的信息来与这些子进程通信，只需要引入一个100行左右代码的适配器类库即可完成通信协议， Storm 提供了Ruby , Python 等等语言的类库<br>下面是从 <code>WordCountTopology</code> 到 <code>SplitSentence</code> 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentence</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SplitSentence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"python"</span>, <span class="string">"splitsentence.py"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SplitSentence</code> 重写了父类的<code>ShellBolt</code>方法， 声明它用 <code>splitsentence.py</code> 作为参数来运行<code>python</code>， 下面是<code>splitsentence.py</code> 的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> storm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitSentenceBolt</span><span class="params">(storm.BasicBolt)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, tup)</span>:</span></span><br><span class="line">        words = tup.values[<span class="number">0</span>].split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">          storm.emit([word])</span><br><span class="line"></span><br><span class="line">SplitSentenceBolt().run()</span><br></pre></td></tr></table></figure>
<p>关于如何用其他语言编写 spouts 和 bolts 以及如何用其他语言编写 topology 的内容,请查阅<br> <a href="http://storm.apache.org/documentation/Using-non-JVM-languages-with-Storm.html" target="_blank" rel="external">Using non-JVM languages with Storm</a>.</p>
<h2 id="保证消息处理的可靠性">保证消息处理的可靠性</h2><p>教程的前面我们略过了一些 tuple 发射方面的内容，这些方面的内容就是 Storm 的可靠性 API， 即 Storm 是如何保证从 spout 中出来的信息都能够被完全的处理，阅读 <a href="http://storm.apache.org/documentation/Guaranteeing-message-processing.html" target="_blank" rel="external">Guaranteeing message processing f</a> 来了解它是如何运作的，以及作为一个用户如何利用 Storm 的可靠性能力。</p>
<h2 id="Transactional_Topologies">Transactional Topologies</h2><p>Storm guarantees that every message will be played through the topology at least once. A common question asked is “how do you do things like counting on top of Storm? Won’t you overcount?” Storm has a feature called transactional topologies that let you achieve exactly-once messaging semantics for most computations. Read more about transactional topologies <a href="http://storm.apache.org/documentation/Transactional-topologies.html" target="_blank" rel="external">here</a>.</p>
<h2 id="分布式_RPC">分布式 RPC</h2><p>这篇教程解释了如何在 Storm 上做基本的流处理。当然你还可以用 Storm 的基础组件做更多的事。其中一个非常有趣的应用是分布式 RPC，在这些 RPC机器上做繁忙的并行计算，阅读更多关于<a href="http://storm.apache.org/documentation/Distributed-RPC.html" target="_blank" rel="external">分布式RPC</a></p>
<h2 id="总结">总结</h2><p>这个教程给出了 如何开发、测试以及部署 Storm topology 的概览，其余的文档将深入到使用 Storm 使用的方方面面。</p>
<h2 id="备注">备注</h2><p>原文 <a href="http://storm.apache.org/tutorial.html" target="_blank" rel="external">Tutorial</a><br>版权所有 <a href="http://www.dahouduan.com">大后端</a>,转载请留链接</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/26/A-Personal-Tailed-AI/" itemprop="url">
                一种私人定制的人工智能机器人
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-26T00:05:56+08:00" content="2015-10-26">
            2015-10-26
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/10/26/A-Personal-Tailed-AI/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/26/A-Personal-Tailed-AI/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>&emsp;&emsp;我想象制作一种人工智能机器人，这个机器人只认一个主人，那就是你，当机器人第一次激活或者初始化时，可以填入你的一些资料比如，身高，体重，三围，职业，爱好，等等各种与使用者相关的资料，初始化的过程就是AI机器人根据这些资料自动生成与你的交互程序，以及自动在互联网上学习知识来应对你的各种问题，或者为你提供更好的服务。<br>&emsp;&emsp;当然这种机器人是会动态学习的，如果你告诉了他你的新资料，它会在夜晚休眠的时候更新自己的交互程序和数据库。<br>&emsp;&emsp;这里的重点是所有的交互都是定制过的，它是只为你服务的，包括说话的语调，长短，句式，我不知道这种AI机器人会成为你的爱人，挚友，或者是宠物，也许你可以直接告诉它你希望它和你是什么关系<br>&emsp;&emsp;从技术上说，最难实现的部分有两个，一个是语义分析或者叫自然语言处理，这个就不说了，百度那么大的公司一直在做这个，但是我也没看出他们有多大进展，另外一个是对话语境或者上下文，如果想让机器跟人产生更深刻的情感联系，机器要知道人是在什么语境下说的话，才能给出使人才生情感共鸣的话，这的确很难，人类的语言一点都不纯粹，它夹杂人的情感和欲望，而机器只有逻辑，也许这是一个无解的难题，在0和1构成的计算机世界里，如何构建出情感，想想有点夸张，逻辑能进化出情感么，也许这是个哲学问题。<br>&emsp;&emsp;不管怎么说，技术总是在发展，机器会越来越懂人类，那么这种私人定制的机器人，以后也许你代替你的电脑，它是最懂你，最聪明，最会讨你喜欢的一个好伴侣。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/19/wait/" itemprop="url">
                等待
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-19T16:24:29+08:00" content="2015-09-19">
            2015-09-19
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/19/wait/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/19/wait/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>&emsp;&emsp;我租住的房子有三间，隔壁住着我的母亲，一个午后，我睡着了。</p>
<p>&emsp;&emsp;那是一个初秋阳光灿烂的午后，那种灿烂的程度是感觉如果不出去走走，就会感觉自己是在被囚禁。但是我却睡着了，我窝在一个小沙发里，靠着侧面的靠背，头与靠背贴着，身体跟垫子贴着，虽然头和身体的中间还是有几块柔软的垫子，睡着后的感觉是并不一样的，沙发左边靠着的我屋里唯一的窗户，外面是楼宇遮挡下的大片阴影和阳光直射的大片阳光，还有树叶遮挡下的斑驳的阳光。不时的有微微的秋风从窗户吹进来，北方的秋风是我觉的最纯正的秋风，风里有些许的干燥剂，还有些须的提神剂，还有极少量的香味，对，是香味，这种香味很难被察觉到的，这归功于我独特的嗅觉，这种风的质感是轻纱，但是没有轻纱的那么一点摩擦感，它想咖啡的表面那样的光滑。</p>
<p>&emsp;&emsp;没错这里的秋天是我最喜欢的季节，而我却我在这里睡着了，老实说，我并不想这样，但是我始终还是一个人，虽然交过不少朋友，但是现在的我还是一个人，也许我注定是个孤独的人。<br>梦里，我还是在这间房子里，我的隔壁住着母亲，这房子的窗子都是朝西的，秋天午后的阳光总是拉的很长，阳光炙热而不炽烈，明亮耀眼，照到每一间东西上，都会再次反射出来，所以虽然现在才两点，阳光尚未穿进我的屋子，但是我的屋子已经亮了，我的窗子就是最亮的光源。</p>
<p>&emsp;&emsp;我睡的不是很沉，恍惚间我又梦到了母亲，我是个可怜的人，在一个阳光灿烂的午后，却独自窝在沙发上睡着了，我睡的很难受，难受是因为我的头摆放的姿势并不舒服，隐约间我的鼻子和我的眼睛同事嗅到了屋外的阳光，啊，这么美好的午后我却可怜的窝在这里，这时的我应该是在一个沐浴阳光林荫道上漫步，这不是一条树叶浓密的林荫道，大片的阳光穿透下来，林荫道上空无一人，只有我和我的几个小伙伴，她们是几个穿着靓丽的姑娘，不，对绝对不是这样的。他们都是男生，他们是我初中一起放学的小朋友，是我高中一起课间玩耍的大朋友，是我工作时遇到的 soul friends，他们每一个都俏皮可爱，虽然他们都是男生，我真心的希望他们，每天就这里沐浴在斑驳的阳光里，和我一起在这条林荫道上漫步，不用面对世俗，不必被一个个丑姑娘抢去，不会被一个个熊孩子为难。现实中我却不知道他们在哪里，现在的我是一个人，也许这就是我想要的。</p>
<p>&emsp;&emsp;恍惚中，有些热，有些渴，也许我现在挣扎着起来，去小店买个雪糕，然后晒晒太阳也许是再好不过的了。我在挣扎中感觉有人在我的身旁在看我，挣扎着想起来看看是谁，但是身体却动不了，她拍了我一下，我真的感受到了，是的在她拍我之前我已经醒了，但是我身边并没有人，因为我在做梦，但是我知道那是我的姐姐。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/04/golang-user-defined-error/" itemprop="url">
                Golang 自定义错误
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-04T12:51:47+08:00" content="2015-09-04">
            2015-09-04
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/04/golang-user-defined-error/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/04/golang-user-defined-error/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>由于 golang 中接口的特殊性，所有实现了 Error() 方法的对象都可以，被赋值给 error 类型的变量，<br>所以实现起来就很简单，下面直接给出代码了, 这是我自己写的一个简单的demo</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type NameError struct &#123;</span><br><span class="line">    <span class="property">name</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *NameError) Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="command">    return</span> e.<span class="property">name</span> + <span class="string">" is  not valid"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NameToUpper(<span class="property">name</span> <span class="type">string</span>) (<span class="type">string</span>, <span class="keyword">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="property">name</span> != <span class="string">"shanhuhai"</span> &#123;</span><br><span class="line"><span class="command">        return</span>  <span class="string">""</span>, &amp;NameError&#123;<span class="property">name</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> strings.ToUpper(<span class="property">name</span>), nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="property">name</span> := <span class="string">"shanhuhai"</span></span><br><span class="line">    <span class="keyword">if</span> upper , err := NameToUpper(<span class="property">name</span>); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="property">name</span> + <span class="string">"'s upper case is "</span> + upper )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/07/17/docker-1-7-install-on-centos-7/" itemprop="url">
                Centos 7 安装 docker 1.7
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-07-17T00:58:38+08:00" content="2015-07-17">
            2015-07-17
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/07/17/docker-1-7-install-on-centos-7/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/17/docker-1-7-install-on-centos-7/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Centos 7 自带 3.10 内核，且 systemctl 启动管理程序对 docker 也提供了很好的支持</p>
<p>##安装 docker 1.7<br>    yum -y install wget<br>    wget -c <a href="https://get.docker.com/rpm/1.7.1/centos-7/RPMS/x86_64/docker-engine-1.7.1-1.el7.centos.x86_64.rpm" target="_blank" rel="external">https://get.docker.com/rpm/1.7.1/centos-7/RPMS/x86_64/docker-engine-1.7.1-1.el7.centos.x86_64.rpm</a><br>    yum localinstall –nogpgcheck docker-engine-1.7.1-1.el7.centos.x86_64.rpm</p>
<p>ok 装完啦！</p>
<h2 id="启动_docker">启动 docker</h2><pre><code>chkconfig docker <span class="command"><span class="keyword">on</span></span>
systemctl <span class="built_in">start</span> docker.service
</code></pre><p>设置开机自动启动并且马上启动！<br>这时候 docker 已经启动了</p>
<pre><code><span class="title">docker</span> images
</code></pre><p>显示目前本地镜像库是空的</p>
<h2 id="一些坑">一些坑</h2><h3 id="docker启动参数不生效">docker启动参数不生效</h3><p><code>/ect/sysconfig/docker</code> 这个文件是 docker 的启动配置参数，具体有哪些参数，你可以 <code>docker -h</code> 看看。<br>这个文件中，有个 <code>other_args=&quot;&quot;</code> 你可以将你的参数 放到双引号中, 比如你在网上找了个加速镜像， 你可以改成</p>
<pre><code><span class="setting">other_args=<span class="value"><span class="string">"--registry-mirror=http://xxx.m.daocloud.io"</span></span></span>
</code></pre><p>但是 <code>systemctl restart docker.service</code> 重起后，并没有生效，所以要改 docker 的service 配置,编辑 <code>/usr/lib/systemd/system/docker.service</code>, 将</p>
<pre><code>ExecStart=/usr/bin/docker -<span class="keyword">d</span> -<span class="keyword">H</span> fd:<span class="comment">//</span>
</code></pre><p>改为</p>
<pre><code>EnvironmentFile=-/etc/sysconfig/docker
ExecStart=/usr/bin/docker -d -H fd:// <span class="variable">$other</span>_args
</code></pre><p>保存后 systemctl restart docker.service 就行了</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/06/29/architect-lvs-dr-mode/" itemprop="url">
                lvs 负载均衡配置(dr 模式)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-06-29T10:50:40+08:00" content="2015-06-29">
            2015-06-29
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/06/29/architect-lvs-dr-mode/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/29/architect-lvs-dr-mode/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>负载均衡机 load blancer</p>
<p>#!/bin/bash<br>GW=10.2.19.255  </p>
<h1 id="website_director_vip-">website director vip.</h1><p>SNS_VIP=10.2.19.83<br>SNS_RIP1=10.2.19.85<br>SNS_RIP2=10.2.19.86  </p>
<p>logger $0 called with $1<br>case “$1” in<br>start)  </p>
<h1 id="set_squid_vip">set squid vip</h1><p>  /sbin/ipvsadm –set 30 5 60<br>  /sbin/ifconfig eth1:0 $SNS_VIP broadcast $SNS_VIP netmask 255.255.255.255 up<br>  /sbin/route add -host $SNS_VIP dev eth1:0<br>  /sbin/ipvsadm -A -t $SNS_VIP:80 -s wrr -p 3<br>  /sbin/ipvsadm -a -t $SNS_VIP:80 -r $SNS_RIP1:80 -g -w 1<br>  /sbin/ipvsadm -a -t $SNS_VIP:80 -r $SNS_RIP2:80 -g -w 1<br>  touch /var/lock/subsys/ipvsadm &gt;/dev/null 2&gt;&amp;1<br>  ;;<br>stop)<br>  /sbin/ipvsadm -C<br>  /sbin/ipvsadm -Z<br>  ifconfig eth1:0 down<br>  ifconfig eth1:1 down<br>  route del $SNS_VIP<br>  rm -rf /var/lock/subsys/ipvsadm &gt;/dev/null 2&gt;&amp;1<br>  echo “ipvsadm stoped”<br>  ;;<br>status)<br>  if [ ! -e /var/lock/subsys/ipvsadm ];then<br>  echo “ipvsadm stoped”<br>  exit 1<br>  else<br>  echo “ipvsadm OK”<br>  fi<br>  ;;<br>*)<br> echo “Usage: $0 {start|stop|status}”<br> exit 1<br>esac<br> exit 0</p>
<p>真实机</p>
<p>#!/bin/bash<br>. /etc/init.d/functions<br>SNS_VIP=10.2.19.83</p>
<p>case “$1” in<br>start)<br>      ifconfig lo:0 $SNS_VIP netmask 255.255.255.255 broadcast $SNS_VIP<br>      /sbin/route add -host $SNS_VIP dev lo:0<br>      echo “1” &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore<br>      echo “2” &gt;/proc/sys/net/ipv4/conf/lo/arp_announce<br>      echo “1” &gt;/proc/sys/net/ipv4/conf/all/arp_ignore<br>      echo “2” &gt;/proc/sys/net/ipv4/conf/all/arp_announce<br>      sysctl -p &gt;/dev/null 2&gt;&amp;1<br>      echo “RealServer Start OK”<br>      ;;<br>stop)<br>     ifconfig lo:0 down<br>      route del $SNS_VIP &gt;/dev/null 2&gt;&amp;1<br>      echo “0” &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore<br>      echo “0” &gt;/proc/sys/net/ipv4/conf/lo/arp_announce<br>      echo “0” &gt;/proc/sys/net/ipv4/conf/all/arp_ignore<br>      echo “0” &gt;/proc/sys/net/ipv4/conf/all/arp_announce<br>      echo “RealServer Stoped”<br>      ;;<br>*)<br>      echo “Usage: $0 {start|stop}”<br>      exit 1<br>esac<br>exit 0 </p>
<p>cp lvs_dr.sh /etc/rc.d/init.d/<br>service lvs_dr.sh start  #启动lvs RS服务器 </p>
<p><a href="http://wolfchen.blog.51cto.com/2211749/1122841" target="_blank" rel="external">http://wolfchen.blog.51cto.com/2211749/1122841</a></p>
<p>修改keepalive日志位置</p>
<p>我们只需要修改 /etc/sysconfig/keepalived 就可以了<br>把KEEPALIVED_OPTIONS=”-D” 修改为KEEPALIVED_OPTIONS=”-D -d -S 0”</p>
<p>最后设置syslog，修改/etc/rsyslog.conf<br>最后添加：</p>
<h1 id="keepalived_-S_0">keepalived -S 0</h1><p>local0.*                                                /var/log/keepalived.log<br>重新启动日志<br>/etc/init.d/rsyslog restart<br>使用以下命令进行验证<br>/etc/init.d/keepalived restart;tailf /var/log/keepalived.log</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/06/24/Linux-useradd-groupadd/" itemprop="url">
                Linux中添加用户和用户组
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-06-24T14:12:24+08:00" content="2015-06-24">
            2015-06-24
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/06/24/Linux-useradd-groupadd/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/24/Linux-useradd-groupadd/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>创建 mysql 组，并设置 groupid 为 10001<br>useradd -g 10001 mysql</p>
<p>创建 mysql 用户，指定用户 uid 为 10001，不能通过shell登录,不创建用户目录，指定用户组为mysql<br>useradd -u 10001 -s /sbin/nologin -M -g mysql mysql</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars1.githubusercontent.com/u/2910488?v=3&s=460" alt="Aron Gao" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Aron Gao</p>
        </div>
        <p class="site-description motion-element" itemprop="description">编码计算、架构技术、服务器技术、云计算技术、挖掘机技术....</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">89</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/shanhuhai" target="_blank">github</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aron Gao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dahouduan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
